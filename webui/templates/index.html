<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>YTArchiver Web UI</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
    {% macro control_button(job, label, action, tone='') -%}
    <button type="button" class="control-btn{% if tone %} {{ tone }}{% endif %}" data-job-id="{{ job.id }}" data-action="{{ action }}">{{ label }}</button>
    {%- endmacro %}

    {% macro control_group(job) -%}
    <div class="control-group" data-controls>
        {%- if job.status == 'running' -%}
            {{ control_button(job, 'Pause', 'pause') }}
            {{ control_button(job, 'Stop', 'stop', 'danger') }}
        {%- elif job.status == 'queued' -%}
            {{ control_button(job, 'Pause', 'pause') }}
            {{ control_button(job, 'Stop', 'stop', 'danger') }}
            {{ control_button(job, 'Delete', 'delete', 'muted') }}
        {%- elif job.status == 'paused' -%}
            {{ control_button(job, 'Resume', 'resume', 'primary') }}
            {{ control_button(job, 'Stop', 'stop', 'danger') }}
            {{ control_button(job, 'Delete', 'delete', 'muted') }}
        {%- elif job.status in ['stopped', 'failed'] -%}
            {{ control_button(job, 'Resume', 'resume', 'primary') }}
            {{ control_button(job, 'Delete', 'delete', 'muted') }}
        {%- elif job.status == 'completed' -%}
            {{ control_button(job, 'Delete', 'delete', 'muted') }}
        {%- endif -%}
    </div>
    {%- endmacro %}

    {% macro progress_text(progress) -%}
        {%- if not progress -%}
            —
        {%- else -%}
            {%- set total = progress.batch_total or 0 -%}
            {%- set prefix = '' -%}
            {%- if total -%}
                {%- set index = progress.batch_index or 1 -%}
                {%- set prefix = '[' ~ index ~ '/' ~ total ~ '] ' -%}
            {%- endif -%}
            {%- set label = progress.label or '' -%}
            {%- if progress.show_transfer -%}
                {%- set label = (label ~ '…') -%}
            {%- endif -%}
            {%- set content = (prefix ~ label)|trim -%}
            {%- if content -%}
                {{ content }}{% if progress.percent is not none %} {{ progress.percent }}%{% endif %}
            {%- elif progress.percent is not none -%}
                {{ progress.percent }}%
            {%- else -%}
                —
            {%- endif -%}
        {%- endif -%}
    {%- endmacro %}

    <main>
        <header>
            <h1>YTArchiver Dashboard</h1>
            <p>Kick off channel, Shorts, or single-video jobs from your browser.</p>
        </header>

        {% if error %}
        <div class="alert">{{ error }}</div>
        {% endif %}

        <section class="panel">
            <h2>New Job</h2>
            <form method="post" class="job-form">
                <div class="field-group">
                    <label>Mode</label>
                    <div class="option-row">
                        <label><input type="radio" name="command" value="channel" checked /> Channel</label>
                        <label><input type="radio" name="command" value="shorts" /> Shorts</label>
                        <label><input type="radio" name="command" value="video" /> Video list</label>
                    </div>
                </div>

                <div class="field-group" id="handle-group">
                    <label for="handle">Channel handle (with or without @)</label>
                    <input type="text" id="handle" name="handle" placeholder="@example" />
                </div>

                <div class="field-group" id="video-group">
                    <label for="video_ids">Video IDs / URLs (comma or newline separated)</label>
                    <textarea id="video_ids" name="video_ids" rows="3" placeholder="dQw4w9WgXcQ"></textarea>
                </div>

                <div class="field-row">
                    <label for="out">Output directory</label>
                    <input type="text" id="out" name="out" value="yt" />
                </div>

                <div class="field-row">
                    <label for="log_file">Log file (optional)</label>
                    <input type="text" id="log_file" name="log_file" placeholder="logs/webui-job.log" />
                </div>

                <div class="field-row grid">
                    <label class="toggle">
                        <input type="checkbox" name="subs" />
                        <span class="toggle-track"><span class="toggle-thumb"></span></span>
                        <span class="toggle-label">Download subtitles</span>
                    </label>
                    <label class="toggle">
                        <input type="checkbox" name="no_cache" />
                        <span class="toggle-track"><span class="toggle-thumb"></span></span>
                        <span class="toggle-label">Disable archive cache</span>
                    </label>
                    <label class="toggle">
                        <input type="checkbox" name="no_clear" />
                        <span class="toggle-track"><span class="toggle-thumb"></span></span>
                        <span class="toggle-label">Disable console clearing</span>
                    </label>
                </div>

                <div class="field-row">
                    <label for="log_level">Log level</label>
                    <select id="log_level" name="log_level">
                        <option value="DEBUG">DEBUG</option>
                        <option value="INFO" selected>INFO</option>
                        <option value="WARNING">WARNING</option>
                        <option value="ERROR">ERROR</option>
                        <option value="CRITICAL">CRITICAL</option>
                    </select>
                </div>

                <button type="submit">Start Job</button>
                <p id="form-status" class="form-status" hidden></p>
            </form>
        </section>

        <section class="panel">
            <h2>Recent Jobs</h2>
            <p id="job-empty-note" class="empty-note" {% if jobs %}hidden{% endif %}>No jobs started yet.</p>
            <div class="job-table" id="job-table">
                <div class="job-row header">
                    <span>ID</span>
                    <span>Status</span>
                    <span>Queue</span>
                    <span>Mode</span>
                    <span>Target</span>
                    <span>Progress</span>
                    <span>Error</span>
                    <span>Controls</span>
                    <span>Logs</span>
                    <span>API</span>
                </div>
                <div id="job-rows" class="job-rows">
                    {% for job in jobs %}
                    {% set progress = job.progress or {} %}
                    <div class="job-row" id="job-{{ job.id }}" data-job-id="{{ job.id }}" data-status="{{ job.status }}">
                        <span class="mono" data-role="short-id">{{ job.id[:8] }}…</span>
                        <span class="status {{ job.status }}" data-status>{{ job.status|capitalize }}</span>
                        <span class="queue-pill" data-queue>
                            {% if job.queue_position %}#{{ job.queue_position }}{% else %}—{% endif %}
                        </span>
                        <span data-role="mode">{{ job.command }}</span>
                        <span data-role="target">
                            {% if job.command == 'video' %}
                                {% set raw_ids = job.video_ids | default([], true) %}
                                {% set count = job.video_count or raw_ids|length %}
                                {{ count }} video{% if count != 1 %}s{% endif %}
                            {% else %}
                                {{ job.handle or 'n/a' }}
                            {% endif %}
                        </span>
                        <span class="progress-text" data-progress>{{ progress_text(progress) }}</span>
                        <span data-role="error">{{ job.error or '—' }}</span>
                        <span class="control-cell">
                            {{ control_group(job) }}
                        </span>
                        <span>
                            <button type="button" class="log-btn" data-log-button data-job-id="{{ job.id }}">View log</button>
                        </span>
                        <span data-role="api">
                            <a href="{{ url_for('job_status', job_id=job.id) }}" target="_blank" rel="noopener">JSON</a>
                        </span>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </section>

        <section class="panel">
            <h2>Watchlist</h2>
            <p>The daemon checks these channels periodically for new uploads and queues download jobs automatically.</p>
            <div id="watchlist-table">
                <div class="watchlist-row header">
                    <span>ID</span>
                    <span>Handle</span>
                    <span>Mode</span>
                    <span>Interval</span>
                    <span>Last Check</span>
                    <span>Last Job</span>
                    <span>Controls</span>
                </div>
                <div id="watchlist-rows" class="watchlist-rows">
                    
                </div>
            </div>
            <button type="button" id="add-watch-btn">Add Channel</button>
        </section>

        <section class="panel log-panel">
            <h2>Log Viewer</h2>
            <p id="log-meta">Select a job to stream the latest 200 lines.</p>
            <pre id="log-output">No job selected.</pre>
        </section>
    </main>

    <script>
        (() => {
            const modeInputs = document.querySelectorAll('input[name="command"]');
            const handleGroup = document.getElementById('handle-group');
            const videoGroup = document.getElementById('video-group');
            const jobRows = document.getElementById('job-rows');
            const emptyNote = document.getElementById('job-empty-note');
            const jobForm = document.querySelector('.job-form');
            const formStatus = document.getElementById('form-status');
            const logOutput = document.getElementById('log-output');
            const logMeta = document.getElementById('log-meta');
            const watchlistRows = document.getElementById('watchlist-rows');
            const addWatchBtn = document.getElementById('add-watch-btn');
            const watchlistState = new Map();
            const jobState = new Map();
            const pendingCommands = new Set();
            const STATUS_CLASSES = ['queued', 'running', 'completed', 'failed', 'paused', 'stopped'];
            const CONTROL_MAP = {
                queued: [
                    { label: 'Pause', action: 'pause' },
                    { label: 'Stop', action: 'stop', tone: 'danger' },
                    { label: 'Delete', action: 'delete', tone: 'muted' },
                ],
                running: [
                    { label: 'Pause', action: 'pause' },
                    { label: 'Stop', action: 'stop', tone: 'danger' },
                ],
                paused: [
                    { label: 'Resume', action: 'resume', tone: 'primary' },
                    { label: 'Stop', action: 'stop', tone: 'danger' },
                    { label: 'Delete', action: 'delete', tone: 'muted' },
                ],
                stopped: [
                    { label: 'Resume', action: 'resume', tone: 'primary' },
                    { label: 'Delete', action: 'delete', tone: 'muted' },
                ],
                failed: [
                    { label: 'Resume', action: 'resume', tone: 'primary' },
                    { label: 'Delete', action: 'delete', tone: 'muted' },
                ],
                completed: [
                    { label: 'Delete', action: 'delete', tone: 'muted' },
                ],
            };

            const controlKey = (jobId, action) => `${jobId}:${action}`;
            let socket = null;
            let activeJob = null;

            function syncFields() {
                const selected = document.querySelector('input[name="command"]:checked');
                if (!selected) { return; }
                const mode = selected.value;
                if (handleGroup) {
                    handleGroup.style.display = mode === 'video' ? 'none' : 'block';
                }
                if (videoGroup) {
                    videoGroup.style.display = mode === 'video' ? 'block' : 'none';
                }
            }

            modeInputs.forEach((input) => input.addEventListener('change', syncFields));
            syncFields();

            function setFormStatus(message, state = 'info') {
                if (!formStatus) { return; }
                if (!message) {
                    formStatus.textContent = '';
                    formStatus.hidden = true;
                    return;
                }
                formStatus.textContent = message;
                formStatus.hidden = false;
                formStatus.dataset.state = state;
            }

            function shortId(id) {
                return id ? `${id.slice(0, 8)}…` : '';
            }

            function formatQueue(job) {
                const value = Number(job.queue_position);
                return Number.isFinite(value) && value > 0 ? `#${value}` : '—';
            }

            function formatTarget(job) {
                if (job.command === 'video') {
                    const totalRaw = typeof job.video_count === 'number' ? job.video_count : (Array.isArray(job.video_ids) ? job.video_ids.length : 0);
                    const total = Number.isFinite(totalRaw) ? totalRaw : 0;
                    const suffix = total === 1 ? '' : 's';
                    return `${total} video${suffix}`;
                }
                return job.handle || 'n/a';
            }

            function formatProgress(job) {
                const progress = job.progress;
                if (!progress) { return '—'; }
                let prefix = '';
                const total = Number(progress.batch_total) || 0;
                if (total > 0) {
                    const rawIndex = Number(progress.batch_index) || 1;
                    prefix = `[${rawIndex}/${total}]`;
                }
                let label = progress.label || '';
                if (progress.show_transfer) {
                    label = `${label}…`;
                }
                const head = [prefix, label].filter(Boolean).join(' ').trim();
                if (!head && typeof progress.percent !== 'number') {
                    return '—';
                }
                if (typeof progress.percent === 'number') {
                    return `${head || ''} ${progress.percent}%`.trim();
                }
                return head || '—';
            }

            function setStatusClass(target, status) {
                if (!target) { return; }
                STATUS_CLASSES.forEach((cls) => target.classList.remove(cls));
                target.classList.add(status);
                target.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            }

            function renderControls(container, job) {
                if (!container) { return; }
                const defs = CONTROL_MAP[job.status] || [];
                container.innerHTML = '';
                if (!defs.length) {
                    container.innerHTML = '<span class="muted">—</span>';
                    return;
                }
                defs.forEach((def) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'control-btn';
                    if (def.tone) {
                        button.classList.add(def.tone);
                    }
                    button.dataset.jobId = job.id;
                    button.dataset.action = def.action;
                    button.textContent = def.label;
                    if (pendingCommands.has(controlKey(job.id, def.action))) {
                        button.disabled = true;
                        button.textContent = `${def.label}…`;
                    }
                    container.appendChild(button);
                });
            }

            function ensureRow(job) {
                if (!jobRows) { return null; }
                let row = document.getElementById(`job-${job.id}`);
                if (row) {
                    return row;
                }
                row = document.createElement('div');
                row.className = 'job-row';
                row.id = `job-${job.id}`;
                row.dataset.jobId = job.id;
                row.innerHTML = `
                    <span class="mono" data-role="short-id"></span>
                    <span class="status" data-status></span>
                    <span class="queue-pill" data-queue>—</span>
                    <span data-role="mode"></span>
                    <span data-role="target"></span>
                    <span class="progress-text" data-progress>—</span>
                    <span data-role="error">—</span>
                    <span class="control-cell"><div class="control-group" data-controls></div></span>
                    <span><button type="button" class="log-btn" data-log-button data-job-id="${job.id}">View log</button></span>
                    <span data-role="api"><a href="${window.location.origin}/jobs/${job.id}.json" target="_blank" rel="noopener">JSON</a></span>
                `;
                jobRows.prepend(row);
                if (emptyNote) {
                    emptyNote.hidden = true;
                }
                return row;
            }

            function updateRow(job) {
                const row = ensureRow(job);
                if (!row) { return; }
                row.dataset.status = job.status;
                const short = row.querySelector('[data-role="short-id"]');
                if (short) {
                    short.textContent = shortId(job.id);
                }
                const statusBadge = row.querySelector('[data-status]');
                setStatusClass(statusBadge, job.status);
                const queueCell = row.querySelector('[data-queue]');
                if (queueCell) {
                    queueCell.textContent = formatQueue(job);
                }
                const modeCell = row.querySelector('[data-role="mode"]');
                if (modeCell) {
                    modeCell.textContent = job.command || '—';
                }
                const targetCell = row.querySelector('[data-role="target"]');
                if (targetCell) {
                    targetCell.textContent = formatTarget(job);
                }
                const progressCell = row.querySelector('[data-progress]');
                if (progressCell) {
                    progressCell.textContent = formatProgress(job);
                }
                const errorCell = row.querySelector('[data-role="error"]');
                if (errorCell) {
                    errorCell.textContent = job.error || '—';
                }
                const apiLink = row.querySelector('[data-role="api"] a');
                if (apiLink) {
                    apiLink.href = `${window.location.origin}/jobs/${job.id}.json`;
                }
                const logButton = row.querySelector('[data-log-button]');
                if (logButton) {
                    logButton.dataset.jobId = job.id;
                    logButton.textContent = activeJob === job.id ? 'Viewing...' : 'View log';
                }
                const controls = row.querySelector('[data-controls]');
                renderControls(controls, job);
            }

            function removeJob(jobId) {
                jobState.delete(jobId);
                const row = document.getElementById(`job-${jobId}`);
                if (row && row.parentElement) {
                    row.parentElement.removeChild(row);
                }
                if (jobRows && jobRows.children.length === 0 && emptyNote) {
                    emptyNote.hidden = false;
                }
                if (activeJob === jobId && logMeta) {
                    activeJob = null;
                    highlightActiveRow(null);
                    logMeta.textContent = `Job ${shortId(jobId)} deleted.`;
                    logOutput.textContent = '';
                }
            }

            function highlightActiveRow(jobId) {
                document.querySelectorAll('.job-row').forEach((row) => {
                    if (!row.dataset || !row.dataset.jobId) { return; }
                    const isActive = Boolean(jobId && row.dataset.jobId === jobId);
                    row.classList.toggle('active-log', isActive);
                    const button = row.querySelector('[data-log-button]');
                    if (button) {
                        button.disabled = isActive;
                        button.textContent = isActive ? 'Viewing...' : 'View log';
                    }
                });
            }

            function renderLogPayload(payload) {
                if (!logOutput || !logMeta) { return; }
                if (payload.error) {
                    activeJob = null;
                    highlightActiveRow(null);
                    logMeta.textContent = payload.error;
                    logOutput.textContent = '';
                    return;
                }
                activeJob = payload.job_id;
                highlightActiveRow(activeJob);
                const lines = payload.tail || [];
                logOutput.textContent = lines.length ? lines.join('\n') : 'No log output yet.';
                const status = payload.status ? ` · ${payload.status}` : '';
                logMeta.textContent = `Job ${shortId(payload.job_id)}${status}`;
            }

            function markPending(jobId, action) {
                if (!jobId || !action) { return; }
                pendingCommands.add(controlKey(jobId, action));
                const job = jobState.get(jobId);
                if (job) {
                    updateRow(job);
                }
            }

            function clearPending(jobId, action) {
                if (!jobId) { return; }
                if (action) {
                    pendingCommands.delete(controlKey(jobId, action));
                } else {
                    [...pendingCommands].forEach((key) => {
                        if (key.startsWith(`${jobId}:`)) {
                            pendingCommands.delete(key);
                        }
                    });
                }
                const job = jobState.get(jobId);
                if (job) {
                    updateRow(job);
                }
            }

            function requestLog(jobId) {
                if (!socket || socket.readyState !== WebSocket.OPEN) { return; }
                socket.send(JSON.stringify({ type: 'request_log', job_id: jobId, lines: 200 }));
                if (logMeta) {
                    logMeta.textContent = `Job ${shortId(jobId)} · fetching log…`;
                }
            }

            if (jobRows) {
                jobRows.addEventListener('click', (event) => {
                    const control = event.target.closest('.control-btn');
                    if (control && jobRows.contains(control)) {
                        const jobId = control.dataset.jobId;
                        const action = control.dataset.action;
                        if (!jobId || !action) { return; }
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            const currentLabel = control.textContent;
                            control.disabled = true;
                            control.textContent = `${currentLabel}…`;
                            markPending(jobId, action);
                            socket.send(JSON.stringify({ type: 'job_control', job_id: jobId, action }));
                        } else {
                            setFormStatus('Realtime offline; reload to issue controls.', 'error');
                        }
                        return;
                    }
                    const logButton = event.target.closest('[data-log-button]');
                    if (logButton && jobRows.contains(logButton)) {
                        const jobId = logButton.dataset.jobId;
                        if (jobId) {
                            if (socket && socket.readyState === WebSocket.OPEN) {
                                logButton.disabled = true;
                                logButton.textContent = 'Loading…';
                                requestLog(jobId);
                            } else {
                                setFormStatus('Realtime offline; reload to view logs.', 'error');
                            }
                        }
                    }
                });
            }

            if (jobForm) {
                jobForm.addEventListener('submit', (event) => {
                    if (!socket || socket.readyState !== WebSocket.OPEN) {
                        setFormStatus('Realtime offline – submitting via HTTP.', 'error');
                        return;
                    }
                    event.preventDefault();
                    const formData = new FormData(jobForm);
                    const payload = Object.fromEntries(formData.entries());
                    ['subs', 'no_cache', 'no_clear'].forEach((key) => {
                        payload[key] = formData.has(key);
                    });
                    setFormStatus('Submitting job…');
                    socket.send(JSON.stringify({ type: 'create_job', payload }));
                });
            }

            function hydrateFromServer(list) {
                if (!Array.isArray(list)) { return; }
                jobState.clear();
                if (jobRows) {
                    jobRows.innerHTML = '';
                }
                list.forEach((job) => {
                    if (!job || !job.id) { return; }
                    jobState.set(job.id, job);
                    updateRow(job);
                });
                if (emptyNote) {
                    emptyNote.hidden = jobState.size > 0;
                }
            }

            function pump(job) {
                if (!job || !job.id) { return; }
                jobState.set(job.id, job);
                updateRow(job);
            }

            function loadWatchlist() {
                fetch('/api/watchlist')
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            console.error('Failed to load watchlist:', data.error);
                            return;
                        }
                        watchlistState.clear();
                        if (watchlistRows) {
                            watchlistRows.innerHTML = '';
                        }
                        (data.entries || []).forEach(entry => {
                            watchlistState.set(entry.id, entry);
                            renderWatchlistRow(entry);
                        });
                    })
                    .catch(error => console.error('Error loading watchlist:', error));
            }

            function renderWatchlistRow(entry) {
                if (!watchlistRows) return;
                const row = document.createElement('div');
                row.className = 'watchlist-row';
                row.id = 'watch-' + entry.id;
                
                const lastCheck = entry.last_check_ts ? new Date(entry.last_check_ts * 1000).toLocaleString() : 'Never';
                const lastJob = entry.last_enqueued_ts ? new Date(entry.last_enqueued_ts * 1000).toLocaleString() : 'Never';
                
                row.innerHTML = '<span class="mono">' + entry.id + '</span>' +
                    '<span>' + entry.handle + '</span>' +
                    '<span>' + entry.mode + '</span>' +
                    '<span>' + entry.interval_minutes + 'm</span>' +
                    '<span>' + lastCheck + '</span>' +
                    '<span>' + lastJob + '</span>' +
                    '<span class="control-group">' +
                        '<button type="button" class="control-btn muted" data-watch-id="' + entry.id + '" data-action="edit">Edit</button>' +
                        '<button type="button" class="control-btn danger" data-watch-id="' + entry.id + '" data-action="delete">Delete</button>' +
                    '</span>';
                watchlistRows.appendChild(row);
            }

            function addWatchEntry(entry) {
                fetch('/api/watchlist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(entry)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error adding watch entry: ' + data.error);
                        return;
                    }
                    loadWatchlist();
                })
                .catch(error => {
                    console.error('Error adding watch entry:', error);
                    alert('Failed to add watch entry');
                });
            }

            function deleteWatchEntry(entryId) {
                if (!confirm('Are you sure you want to delete this watch entry?')) return;
                
                fetch('/api/watchlist/' + entryId, { method: 'DELETE' })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error deleting watch entry: ' + data.error);
                        return;
                    }
                    loadWatchlist();
                })
                .catch(error => {
                    console.error('Error deleting watch entry:', error);
                    alert('Failed to delete watch entry');
                });
            }

            if (addWatchBtn) {
                addWatchBtn.addEventListener('click', () => {
                    const handle = prompt('Enter YouTube channel handle (with or without @):');
                    if (!handle) return;
                    
                    const entry = {
                        handle: handle.trim(),
                        mode: 'channel',
                        interval_minutes: 60,
                        subs: false,
                        no_cache: false,
                        out_dir: 'yt',
                        log_level: 'INFO',
                        clear_screen: true,
                        tags: []
                    };
                    addWatchEntry(entry);
                });
            }

            if (watchlistRows) {
                watchlistRows.addEventListener('click', (event) => {
                    const button = event.target.closest('.control-btn');
                    if (!button) return;
                    
                    const entryId = parseInt(button.dataset.watchId);
                    const action = button.dataset.action;
                    
                    if (action === 'delete') {
                        deleteWatchEntry(entryId);
                    } else if (action === 'edit') {
                        // For now, just show an alert. Could implement full edit later.
                        alert('Edit functionality not implemented yet. Delete and re-add instead.');
                    }
                });
            }

            // Load watchlist on page load
            loadWatchlist();

            (function initSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                const url = `${protocol}://${window.location.host}/ws`;
                try {
                    socket = new WebSocket(url);
                } catch (error) {
                    console.warn('Unable to connect to websocket', error);
                    setFormStatus('Realtime connection failed. Reload after jobs finish.', 'error');
                    return;
                }

                socket.addEventListener('open', () => {
                    setFormStatus('Realtime connected.', 'success');
                    window.setTimeout(() => setFormStatus(''), 2500);
                });

                socket.addEventListener('message', (event) => {
                    try {
                        const payload = JSON.parse(event.data);
                        switch (payload.type) {
                            case 'jobs_snapshot':
                                hydrateFromServer(payload.jobs);
                                break;
                            case 'job_update':
                                pump(payload.job);
                                break;
                            case 'job_created':
                                setFormStatus(`Queued job ${shortId(payload.job_id)}.`, 'success');
                                if (jobForm) {
                                    jobForm.reset();
                                }
                                syncFields();
                                break;
                            case 'job_log':
                                renderLogPayload(payload);
                                break;
                            case 'job_control_ack':
                                clearPending(payload.job_id, payload.action);
                                break;
                            case 'job_deleted':
                                removeJob(payload.job_id);
                                break;
                            case 'job_error':
                                if (payload.job_id) {
                                    clearPending(payload.job_id, payload.action);
                                    setFormStatus(payload.error || 'Command rejected.', 'error');
                                } else {
                                    setFormStatus(payload.error || 'Unable to create job.', 'error');
                                }
                                break;
                            default:
                                break;
                        }
                    } catch (error) {
                        console.error('Unable to parse message', error);
                    }
                });

                socket.addEventListener('close', () => {
                    socket = null;
                    setFormStatus('Realtime connection closed. Falling back to form submit.', 'error');
                });

                socket.addEventListener('error', () => {
                    setFormStatus('Realtime connection error.', 'error');
                });
            })();
        })();
    </script>
</body>
</html>
